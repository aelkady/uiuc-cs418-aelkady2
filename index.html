<!DOCTYPE HTML> 
<html> 

<script src="unit teapot.js"></script>

<script src="gl-matrix-min.js"></script>

<script>
var gl;
var teapotShaderProgramInfo;
var teapot_vao;
var Textures;

//
// a vertex shader implemented as a backquoted string variable
//

var vs = `#version 300 es

in vec3 aVertexPosition;
in vec3 aVertexNormal;

uniform mat4 uModelMatrix;
uniform mat4 uViewMatrix;
uniform mat3 uNormalMatrix;
uniform mat4 uProjectionMatrix;

out vec3 vNormal;
out vec3 vPosition;
out vec3 normal;
out vec4 modelViewPosition;

void main() {
  vNormal = aVertexNormal;
  vPosition = aVertexPosition;
  normal = uNormalMatrix*aVertexNormal;
  modelViewPosition = uViewMatrix*uModelMatrix*vec4(aVertexPosition, 1.0);

  gl_Position = uProjectionMatrix*modelViewPosition;
}
`;

//
// a fragment shader implemented as a backquoted string variable
//

var fs = `#version 300 es

#define M_PI 3.1415926535

#if __VERSION__ < 130
#define TEXTURE2D texture2D
#else
#define TEXTURE2D texture
#endif

precision mediump float;
    
in vec3 vNormal;
in vec3 vPosition;
in vec3 normal;
in vec4 modelViewPosition;
uniform sampler2D uSampler;
uniform sampler2D uSampler2;

out vec4 outColor;
    
void main() {
  vec2 illinoisTexCoord;
  illinoisTexCoord.s = 1.0-((atan(vPosition.z, vPosition.x))/(2.0*M_PI));
  illinoisTexCoord.t = (vPosition.y+0.25)/0.5;
  vec2 stadiumTexCoord = (normal.xy + 1.0)/2.0;
  vec4 illinois = TEXTURE2D(uSampler, illinoisTexCoord);
  vec4 stadium = TEXTURE2D(uSampler2, stadiumTexCoord);

  vec3 normalizedNormal = normalize(normal);
  vec3 lighting;

  float ks = 0.6;
  vec3 specularLightSourceLocation = vec3(3.5,0.0,3.0);
  vec3 specularLightDirection = normalize(specularLightSourceLocation - modelViewPosition.xyz);
  vec3 eyeDirection = normalize(-modelViewPosition.xyz);
  vec3 specularReflectionDirection = reflect(-specularLightDirection, normalizedNormal);
  float specularLightComponent = pow(max(dot(specularReflectionDirection, eyeDirection), 0.0), 20.0);

  float kd = 0.8;
  vec3 diffuseLightSourceLocation = vec3(1.0,0.0,3.0);
  vec3 diffuseLightDirection = normalize(diffuseLightSourceLocation - modelViewPosition.xyz);
  float diffuseLightComponent = max(dot(normalizedNormal, diffuseLightDirection), 0.0);

  vec3 specularColor = vec3(0.5, 0.5, 0.5);
  vec3 diffuseColor = vec3(0.75, 0.75, 0.75);
  lighting = ks * specularColor * specularLightComponent + kd * diffuseColor * diffuseLightComponent;

  vec4 fragmentColor = (illinois + stadium);
  vec4 c = vec4(fragmentColor.rgb * lighting, fragmentColor.a);

  outColor = c;
}
`;

function loadshaders(vertexShaderSource,fragmentShaderSource) {
  var vertexShader = gl.createShader(gl.VERTEX_SHADER);
  gl.shaderSource(vertexShader, vertexShaderSource);
  gl.compileShader(vertexShader);
  if (!gl.getShaderParameter(vertexShader, gl.COMPILE_STATUS))
    alert("Vertex Shader Error:\n" + gl.getShaderInfoLog(vertexShader));

  var fragmentShader = gl.createShader(gl.FRAGMENT_SHADER);
  gl.shaderSource(fragmentShader, fragmentShaderSource);
  gl.compileShader(fragmentShader);
  if (!gl.getShaderParameter(fragmentShader, gl.COMPILE_STATUS))
    alert("Fragment Shader Error:\n" + gl.getShaderInfoLog(fragmentShader));

  //
  // Compile shaders and get link ID's to the attributes and uniforms
  //

  var shaderProgram = gl.createProgram();
  gl.attachShader(shaderProgram, vertexShader);
  gl.attachShader(shaderProgram, fragmentShader);
  gl.linkProgram(shaderProgram);
  if (!gl.getProgramParameter(shaderProgram, gl.LINK_STATUS))
    alert("Failed to setup shaders");

  return shaderProgram
}

function bindAndEnableArrayBuffer(dimension, array, glProperty) {
  var buffer = gl.createBuffer();

  gl.bindBuffer(
    gl.ARRAY_BUFFER,
    gl.createBuffer()
  );

  gl.bufferData(
    gl.ARRAY_BUFFER,
    new Float32Array(array),
    gl.STATIC_DRAW
  );

  gl.enableVertexAttribArray(glProperty);

  gl.vertexAttribPointer(
    glProperty,
    dimension,
    gl.FLOAT,
    false,
    0,
    0
  );

  return buffer; 
}

function bindElementArrayBuffer(array) {
  gl.bindBuffer(
    gl.ELEMENT_ARRAY_BUFFER,
    gl.createBuffer()
  ); 

  gl.bufferData(
    gl.ELEMENT_ARRAY_BUFFER,
    new Uint16Array(array),
    gl.STATIC_DRAW
  );
}

function createImageTexture(imageName, imageDimension, index) {
  var texture = gl.createTexture();
  gl.bindTexture(gl.TEXTURE_2D, texture);

  var sampler = gl.createSampler();
  gl.bindSampler(index, sampler);

  gl.texImage2D(
    gl.TEXTURE_2D,
    0,
    gl.RGBA,
    1,
    1,
    0, 
    gl.RGBA,
    gl.UNSIGNED_BYTE,
    new Uint8Array([0, 0, 255, 255])
  );

  //
  // load texture image using webgl2fundamentals boilerplate
  // initially creates just a 1x1 blue pixel as a placeholder
  // replaced by actual texture image once loaded
  //

  var image = new Image();
  image.src = imageName;

  image.addEventListener("load", function() {
    gl.bindTexture(gl.TEXTURE_2D, texture);

    gl.texImage2D(
      gl.TEXTURE_2D,
      0, 
      gl.RGBA,
      imageDimension,
      imageDimension,
      0,
      gl.RGBA,
      gl.UNSIGNED_BYTE,
      image
    );

    gl.generateMipmap(gl.TEXTURE_2D);
  });

  return texture;
}

function normalizeTeapotNormals() {
  var x,y,z,d,i;
  for (i = 0; i < teapot.normals.length; i += 3) {
    x = teapot.normals[i];
    y = teapot.normals[i+1];
    z = teapot.normals[i+2];

    d = 1.0/Math.sqrt(x*x + y*y + z*z);

    teapot.normals[i] *= d;
    teapot.normals[i+1] *= d;
    teapot.normals[i+2] *= d;
    
  }
}

function initwebgl() {

  //
  // create a graphics context
  //

  var canvas = document.getElementById("myGLCanvas");
  gl = canvas.getContext("webgl2");
  if (!gl)
    alert("Failed to create WebGL context!");

  gl.pixelStorei(gl.UNPACK_FLIP_Y_WEBGL, true);

  var shaderProgram = loadshaders(vs,fs);

  teapotShaderProgramInfo = {
    program: shaderProgram,
    attributeLocations: {
      vertexPosition: gl.getAttribLocation(shaderProgram, 'aVertexPosition'),
      vertexNormal: gl.getAttribLocation(shaderProgram, 'aVertexNormal')
    },
    uniformLocations: {
      projectionMatrix: gl.getUniformLocation(shaderProgram, 'uProjectionMatrix'),
      modelMatrix: gl.getUniformLocation(shaderProgram, 'uModelMatrix'),
      viewMatrix: gl.getUniformLocation(shaderProgram, 'uViewMatrix'),
      normalMatrix: gl.getUniformLocation(shaderProgram, 'uNormalMatrix'),
      uSampler: gl.getUniformLocation(shaderProgram, 'uSampler'),
      uSampler2: gl.getUniformLocation(shaderProgram, 'uSampler2'),
      isPlane: gl.getUniformLocation(shaderProgram, 'isPlane')
    },
  };

  // set up vertex array object
 
  teapot_vao = gl.createVertexArray();
  gl.bindVertexArray(teapot_vao);

  // create a coordinate buffer of vertex positions and
  // connect it to the vertex shader positions

  bindAndEnableArrayBuffer(
    3,
    teapot.positions,
    teapotShaderProgramInfo.attributeLocations.vertexPosition
  );

  // create a coordinate buffer of vertex positions and
  // connect it to the vertex shader positions
  // but normalize the normals first

  normalizeTeapotNormals();
  bindAndEnableArrayBuffer(
    3,
    teapot.normals,
    teapotShaderProgramInfo.attributeLocations.vertexNormal
  );

  // create an index buffer of triangle faces
  
  bindElementArrayBuffer(teapot.faces);

  //
  // set up textures
  //

  Textures = {
    illinoisImageTexture: createImageTexture("illinois512.png", 512, 0),
    stadiumImageTexture: createImageTexture("stadium sphere.jpg", 256, 1),
    bind: function() {
        gl.uniform1i(teapotShaderProgramInfo.uniformLocations.uSampler,0);
        gl.uniform1i(teapotShaderProgramInfo.uniformLocations.uSampler2,1);

        gl.activeTexture(gl.TEXTURE0);
        gl.bindTexture(gl.TEXTURE_2D, Textures.illinoisImageTexture);
        gl.activeTexture(gl.TEXTURE1);
        gl.bindTexture(gl.TEXTURE_2D, Textures.stadiumImageTexture);
    },
  };

  requestAnimationFrame(draw);
}

function drawTeapot() {
  gl.bindVertexArray(teapot_vao);
  gl.drawElements(
    gl.TRIANGLES,
    teapot.faces.length,
    gl.UNSIGNED_SHORT,
    0
  );
}

const Matrices = {
  Projection: function() {
    var projection = glMatrix.mat4.create();
    glMatrix.mat4.perspective(projection, Math.PI/6, 1.0, 0.1);
    return projection;
  },
  Model: function(time) {
    var model = glMatrix.mat4.create();
    glMatrix.mat4.scale(model,model,[0.89,0.89,0.89]);
    glMatrix.mat4.translate(model,model,[0, 0.3, -2.25]);
    glMatrix.mat4.rotateY(model,model, time*0.001);
    return model
  },
  View: function() {
    var view = glMatrix.mat4.create();
    let eye = glMatrix.vec3.fromValues(1, 1, 0);
    let camera = glMatrix.vec3.fromValues(0,0,-2);
    let up = glMatrix.vec3.fromValues(0,1,0);
    glMatrix.mat4.lookAt(view, eye, camera, up);
    return view
  },
  Normal: function(modelView) {
    var normal = glMatrix.mat3.create();
    glMatrix.mat3.normalFromMat4(normal, modelView);
    return normal
  },
  bind: function(time) {
    //
    // set up transformation matrices
    //
    var model = Matrices.Model(time);
    gl.uniformMatrix4fv(teapotShaderProgramInfo.uniformLocations.modelMatrix, false, model);
    var view = Matrices.View();
    gl.uniformMatrix4fv(teapotShaderProgramInfo.uniformLocations.viewMatrix, false, view);
    var modelView = glMatrix.mat4.create();
    glMatrix.mat4.multiply(modelView, view, model)
    gl.uniformMatrix3fv(teapotShaderProgramInfo.uniformLocations.normalMatrix, false, Matrices.Normal(modelView));
    gl.uniformMatrix4fv(teapotShaderProgramInfo.uniformLocations.projectionMatrix, false, Matrices.Projection());
  }
};

function clearGL() {
  gl.clearColor(0.075, 0.16, 0.294, 1.0);
  gl.clearDepth(1.0);
  gl.enable(gl.DEPTH_TEST);
  gl.depthFunc(gl.LEQUAL);
  gl.clear(gl.COLOR_BUFFER_BIT | gl.DEPTH_BUFFER_BIT);
}

//
// draw callback function that is passed to requestAnimationFrame()
//

function draw(time) {
  clearGL()
  gl.useProgram(teapotShaderProgramInfo.program);
  Matrices.bind(time)
  Textures.bind();
  drawTeapot();
  requestAnimationFrame(draw);
}

</script>

<body onload="initwebgl()">

<canvas id="myGLCanvas" width="500" height="500"></canvas>

</body>
</html>
